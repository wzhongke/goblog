---
title: java 内存以及GC
date: 2019-02-23 12:39:00
tags: ["java"]
categories: ["java"]
---

# java 堆内存
根据 Generation 算法，Java 的堆内存被划分为新生代、老年代和持久代。新生代又进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 FromSpace(Survivor0) 和 ToSpace(Survivo1) 组成。

![Alt text](/img/java堆内存.webp)

![](/img/java堆内存2.webp)

所有通过 `new` 创建的对象都会被分配到堆内存中，堆内存的大小可以通过 `-Xmx` 和 `-Xms` 来控制。

分代收集是基于 不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，并采用不同的回收算法进行回收。

Java 的堆内存以外的部分：
- 栈，每个线程执行方法时都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。
- 本地方法栈，用于支持 native 方法的执行
- 方法区，存放了要加载的类的信息、静态变量、final类型的常亮、属性和方法信息。JVM 用持久代存放方法区，通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 来指定最小和最大值

## 堆内存分配
### 新生代
新生代的内存是按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor 区。

大部分对象在 Eden 区生成，当新对象生成时，会在 Eden 区申请内存，如果申请失败，则会发起一次新生代的 GC。

回收时现将 Eden 区存活对象复制到 Survivor0 区，然后清空 Eden 区。当 Survivor0 区也存放满了，则将 Eden 区和 Survivor0 区存活的对象复制到 Survivor1 区，然后清空 Eden 和 Survivor0 区，然后将 Survivor0 和 Survivor1 区交换，保持 Survivor1 区为空。

如果 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，则将存活对象直接放到老年代。

当对象在 Survivor0 区没有被 GC 的话，则其年龄加1。默认情况下，当对象年龄达到15时，就会用到过到老年代中。

### 老年代
在新生代经历 N 次回收仍然存活的对象，就会被放到老年代中。

老年代一般都是生命周期较长的对象，内存的比例也比新生代大，大概是2:1。

当老年代内存满时触发 Full GC，Full GC 的频率比较低，如果频繁 Full GC 说明内存不够或者有内存溢出。

老年代的对象存活时间比较长。一般来说，大对象会直接被分配到老年代。大对象指的是需要大量连续存储空间的对象。

### 持久代
用于存放静态文件（class类、方法等）和常量。持久代对垃圾回收没有显著影响，但是有些应用（例如Hibernate）可能动态生成或者调用一些class，此时就需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

对永久代回收主要是两部分内容：废弃常量和无用的类。

内存不够时，java8以前会抛出：`java.lang.OutOfMemoryError: PermGen error` 错误。

java8 将永久代移除，用元空间（MetaSpace）代替。

## 堆内存分配策略
- 对象优先在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

