---
title: java 内存以及GC
date: 2019-02-23 12:39:00
tags: ["java"]
categories: ["java"]
---

# java 堆内存
根据 Generation 算法，Java 的堆内存被划分为新生代、老年代和持久代。新生代又进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 FromSpace(Survivor0) 和 ToSpace(Survivo1) 组成。

![Alt text](/img/memory.png)

所有通过 `new` 创建的对象都会被分配到堆内存中，堆内存的大小可以通过 `-Xmx` 和 `-Xms` 来控制。

分代收集是基于 不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，并采用不同的回收算法进行回收。

Java 的堆内存以外的部分：
- 栈，每个线程执行方法时都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果。
- 本地方法栈，用于支持 native 方法的执行
- 方法区，存放了要加载的类的信息、静态变量、final类型的常亮、属性和方法信息。JVM 用持久代存放方法区，通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 来指定最小和最大值

## 堆内存分配
### 新生代
新生代的内存是按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor 区。

大部分对象在 Eden 区生成，当新对象生成时，会在 Eden 区申请内存，如果申请失败，则会发起一次新生代的 GC。

回收时现将 Eden 区存活对象复制到 Survivor0 区，然后清空 Eden 区。当 Survivor0 区也存放满了，则将 Eden 区和 Survivor0 区存活的对象复制到 Survivor1 区，然后清空 Eden 和 Survivor0 区，然后将 Survivor0 和 Survivor1 区交换，保持 Survivor1 区为空。

如果 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，则将存活对象直接放到老年代。

当对象在 Survivor0 区没有被 GC 的话，则其年龄加1。默认情况下，当对象年龄达到15时，就会用到过到老年代中。

### 老年代
在新生代经历 N 次回收仍然存活的对象，就会被放到老年代中。

老年代一般都是生命周期较长的对象，内存的比例也比新生代大，大概是2:1。

当老年代内存满时触发 Full GC，Full GC 的频率比较低，如果频繁 Full GC 说明内存不够或者有内存溢出。

老年代的对象存活时间比较长。一般来说，大对象会直接被分配到老年代。大对象指的是需要大量连续存储空间的对象。

### 持久代
用于存放静态文件（class类、方法等）和常量。持久代对垃圾回收没有显著影响，但是有些应用（例如Hibernate）可能动态生成或者调用一些class，此时就需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。

对永久代回收主要是两部分内容：废弃常量和无用的类。

内存不够时，java8以前会抛出：`java.lang.OutOfMemoryError: PermGen error` 错误。

java8 将永久代移除，用元空间（MetaSpace）代替。

## 堆内存分配策略
- 对象优先在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代

# 垃圾回收算法
垃圾回收一般做两件事
1. 找到所有存活对象
2. 回收无用对象所占用的内存

## 引用计数法
堆中的每个对象都有一个引用计数器。每当有地方引用时，计数器的值就加 1. 当引用失效时，计数器的值就减 1. 任何引用计数为 0 的对象可以被回收，当一个对象被回收时，它引用的任何对象计数减 1.

**优点**：引用计数收集器执行简单，判定效率高，对程序不被长时间打断的实时环境有利
**缺点**：难以检测对象之间的循环引用，同时增加了程序执行开销

## 可达性分析算法
该算法的基本思路：
1. 通过一系列名为 GC Roots 的对象作为起点，寻找对应的引用节点
2. 找到节点后，从这些节点开始向下搜寻它们的引用节点
3. 重复 2
4. 搜索所走过的路径成为引用链，当一个对象到 GC Roots 没有任何引用链相连时，那么该对象是不可用的

一般 GC Roots 包含如下对象：
- 虚拟机栈中引用的对象
- 方法区中的常量引用对象
- 方法区中的类静态属性引用的对象
- 本地方法栈中 JNI （Native 方法） 引用的对象
- 活跃线程

![Alt text](/img/mark.png)

存活对象在上图中被标记为蓝色。标记阶段完成后，所有存活对象都已被标记，剩余的灰色是不可达对象，可以回收掉。

# CMS 回收算法
CMS 全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器。在老年代使用 CMS 垃圾回收器时，需要添加 `-XX:+UseConcMarkSweepGC` 的虚拟机参数。

**使用场景**：GC过程短暂停，适合对延迟要求较高的服务，用户线程不允许长时间的停顿。