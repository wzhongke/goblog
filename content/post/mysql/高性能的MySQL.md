

## 缓存表和汇总表
我们用术语“缓存表”来表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表（例如，逻辑上冗余的数据）。

术语“汇总表”时，则保存的是使用GROUP BY语句聚合数据的表（例如，数据不是逻辑上冗余的）

在使用缓存表和汇总表时，必须决定是实时维护数据还是定期重建。哪个更好依赖于应用程序，但是定期重建并不只是节省资源，也可以保持表不会有很多碎片，以及有完全顺序组织的索引（这会更加高效）

## 加快ALTER TABLE操作的速度
MySQL的ALTER TABLE操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。许多人都有这样的经验，ALTER TABLE操作需要花费数个小时甚至数天才能完成。

下面这些操作是有可能不需要重建表的：
- 移除（不是增加）一个列的AUTO_INCREMENT属性。
- 增加、移除，或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字串值。

基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件，像下面这样（可能会存在问题，不建议如此）：
1. 创建一张有相同结构的空表，并进行所需要的修改（例如增加ENUM常量）。
2. 执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开。
3. 交换.frm文件.
4. 执行UNLOCK TABLES来释放第2步的读锁。


MySQL喜欢简单，需要使用数据库的人应该也同样会喜欢简单的原则：

- 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表设计（很多的意思是介于有点多和非常多之间）。
- 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值。
- 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。
- 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。
- 尽量使用整型定义标识列。
- 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。
- 小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用BIT


# 创建高性能索引
索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询 

对于范围条件查询，MySQL无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。


## 索引的类型
索引一般分为：哈希索引和B-Tree索引。

### B-Tree索引
B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，对如下类型有效：
- 全值匹配：全值匹配指的是和索引中的所有列进行匹配
- 匹配最左前缀：使用索引的前几列。
- 匹配列前缀：也可以只匹配某一列的值的开头部分
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列
- 只访问索引的查询： B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无须访问数据行

B-Tree 索引的限制：
- 如果不是按照索引的最左列开始查找，则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

### 哈希索引

哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效

如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中

哈希索引的限制：
- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行
- 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
- 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的
- 哈希索引只支持等值比较查询，包括=、IN()、<=>（注意<>和<=>是不同的操作
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高

### 全文索引

## 索引优点
总结下来索引有如下三个优点：
- 索引大大减少了服务器需要扫描的数据量。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机I/O变为顺序I/O。

只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录地匹配。

## 高性能索引
正确地创建和使用索引是实现高性能查询的基础。
表中的索引越多插入速度会越慢。一般来说，增加新索引将会导致INSERT、UPDATE、DELETE等操作的速度变慢，特别是当新增索引后导致达到了内存瓶颈的时候

### 独立的列
**如果查询中的列不是独立的，则MySQL就不会使用索引**
“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

### 前缀索引和索引选择性
**前缀索引**是指索引字段中开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性

**索引的选择性**是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间

计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，下列就是计算不用前缀长度的选择性：
```sql
SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
	COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,
	COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,
	COUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6
	FROM city_demo;
```


前缀索引是一种能使索引更小、更快的有效办法，
但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描

### 多列索引
在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能

在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求

对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列，但通常不如避免随机IO和排序那么重要。

不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能，比如 guest 用户特别多的情况

### 聚簇索引
InnoDB 使用的是聚簇索引。
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。

聚集的数据有一些重要的优点：
- 可以把相关数据保存在一起，聚簇数据最大限度地提高了I/O密集型应用的性能。
- 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

聚簇索引也有一些缺点：
- 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。
- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。
- **更新聚簇索引列的代价很高**，因为会强制InnoDB将每个被更新的行移动到新的位置。
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。
- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
- 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
- 二级索引访问需要两次索引查找，而不是一次。

InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。**这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作**。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无须更新二级索引中的这个“指针”。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID来作为聚簇索引则会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。

**对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置**

### 覆盖索引
覆盖索引： 一个索引包含（或者说覆盖）所有需要查询的字段的值

MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行

覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引


索引覆盖查询，在EXPLAIN的Extra列可以看到“Using index”的信息

在表 `products` 中有索引：`(artist，title，prod_id)`，用如下方式查询：

```sql
SELECT *
-> FROM products
->    JOIN (
->       SELECT prod_id
->       FROM products
->       WHERE actor='SEAN CARREY' AND title LIKE '%APOLLO%'
->    ) AS t1 ON (t1.prod_id=products.prod_id)
```

我们把这种方式叫做**延迟关联**（deferred join），因为延迟了对列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配获取需要的所有列值。虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖的好。

### 使用索引来排序
如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序

如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

只有**当索引的列顺序和ORDER BY子句的顺序完全一致**，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序

如果**查询需要关联多张表**，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。


不能使用索引做排序查询：
- 查询使用了两种不同的排序方向，但是索引列都是正序排序的
- 查询的ORDER BY子句中引用了一个不在索引中的列
- 查询在条件索引列上是范围条件

使用索引做排序的一个最重要的用法是当查询同时有ORDER BY和LIMIT子句的时候

InnoDB中，因为二级索引的叶子节点包含了主键值，所以在列（A）上的索引就相当于在（A，ID）上的索引

InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢很多。

## 优化排序
对于那些选择性非常低的列，可以增加一些特殊的索引来做排序，可以创建（sex，rating）索引用于下面的查询：
```sql
 SELECT<cols>  FROM profiles WHERE sex='M' ORDER BY rating LIMIT 10;
```

上述查询同时使用了ORDER BY和LIMIT，如果没有索引的话会很慢。

即使有索引，如果用户界面上需要翻页，并且翻页翻到比较靠后时查询也可能非常慢。

优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。这可以减少MySQL扫描那些需要丢弃的行数。
下面这个查询显示了如何高效地使用（sex，rating）索引进行排序和分页：
```sql
SELECT <cols> FROM profiles INNER JOIN (
         SELECT <primary key cols>FROM profiles
         WHERE x.sex='M' ORDER BY rating LIMIT 100000, 10
        ) AS x USING(<primary key cols>);
```

## 总结
在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：
- 单行访问是很慢的。特别是在机械硬盘存储中（SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。
- 按顺序访问范围数据是很快的，这有两个原因。第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。
- 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。






