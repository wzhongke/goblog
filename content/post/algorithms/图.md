---
title: 图算法
date: 2017-12-22 08:37:00
tags: ["算法"]
categories: ["算法"]
---

# 图的表示
我们用$V$表示图的结点数，$E$表示图的边的条数。
对于图$G=(V,E)$，可以用两种标准表示方法表示：将图作为邻接链表的组合；将图作为邻接矩阵来看待。
**稀疏图**（边的条数$E$远远小于$V^2$的图）通常用邻接链表表示，因为邻接链表非常紧凑。
**稠密图**（边的条数$E$接近$V^2$的图）倾向于用邻接矩阵表示。
**权重图** 图中的每条边都带有一个相关的权重，该权重值通常是由一个$\omega: E\rightarrow R$的**权重函数**给出。

# 广度优先搜索
**广度优先搜索** 是最简单的图搜索算法之一，也是许多重要的图算法原型。
给定图$G=(V,E)$ 和一个可以识别的源结点$s$，广度会选搜索对图$G$中的边进行系统性的探索来发现可以从源结点$s$到达的所有结点。该算法能够计算从源结点$s$到每个可到达的结点的距离，同时生成一棵“广度会选搜索树”。该树以$s$ 为根结点，包含所有可以从 $s$ 到达的结点。对于每个从源结点 $s$ 可以到达的结点 $v$，在广度优先搜索树里从结点 $s$ 到结点 $v$ 的简单路径所对应的就是图 $G$ 中从结点 $s$ 到结点 $v$ 的 “最短路径”，即包含最少边数的路径。该算法即可以用于有向图，也可以用于无向图。

为了跟踪算法，广度会选搜索在概念上将每个结点涂上白色、灰色或黒色。所有结点在一开始均涂上白色。在搜索过程中第一次遇到一个结点就称该结点被**发现**，此时将该结点的颜色涂成灰色，并将该结点放到队列的最后。以某结点作为搜索其相邻结点的结点时，该结点涂成黒色。所有结点为黒色时，搜索结束。

伪代码如下：
```
BFS(G, s)
    for each vertex u in G.V - {s}
        u.color = WHITE
        u.d = ∞
        u.parent = NIL
    s.color = GRAY
    s.d = 0
    s.parent = NIL
    Q = {}
    ENQUEUE(Q, s)
    while Q.size() > 0
        u = DEQUEUE(Q)
        for each v in G.Adj[u]
            if v.color == WHITE
                v.color = GRAY
                v.d = u.d + 1
                v.parent = u
                ENQUEUE(Q,v)
        u.color = BLACK    
```

算法的时间复杂度是 $O(V+E)$
广度优先搜索的结果可能依赖于对每个结点的邻接结点的访问顺序：广度优先树可能会不一样，相计算出来的距离是d是一样的。

## 最短路径
定义从源结点 $s$ 到结点 $v$ 的**最短距离$\delta (s,v)$** 为从结点 $s$ 到结点 $v$ 之间所有路径里面最少的边数，若结点 $s$ 到结点 $v$ 之间没有路径，则 $\delta(s,v)=\infty$。
结点 $s$ 到结点 $v$ 的**最短路径** 是结点 $s$ 到结点 $v$ 的长度为 $\delta(s,v)$ 的路径。

# 深度优先搜索
**深度优先搜索** 总是对最近才发现对结点 $v$ 的出发边进行探索，直到该节点的所有出发边都被发现为止。一旦 $v$ 的出发边都被发现，搜索则“回溯”到 $v$ 的前驱结点，来搜索该前驱结点的出发边。该过程一直持续支从源结点可以达到的所有结点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些从未被发现的结点中任选一个作为新的源结点，并重复同样的过程，直到所有的结点都被发现。
深度优先搜索的前驱子图可能由多棵树组成，因为搜索可能从多个源结点重复进行。其前驱子图形成一个由多棵深度优先树构成的深度优先森林： $G_\pi=(V,E_\pi)$，其中 $E_\pi=\{(v.\pi,v):v\in V $且$v.\pi\neq NIL\}$

除了创建一个深度优先搜索森林外，深度优先搜索算法还在每个结点盖上一个时间戳。每个结点有两个时间戳：第一个时间戳 $v.d$ 记录结点 $v$ 第一次被发现的时间，第二个时间戳 $v.f$ 记录的是搜索完成对 $v$ 邻接链表扫描对时间。这些时间戳提供了图结构对重要信息，能够帮助我们推断深度优先算法对行为。

深度优先搜索算法的伪代码如下：
```
DFS(G)
    for each vertex u in G.V
        u.color = WHITE
        u.parent = NIL
    time = 0
    for each vertex u in G.V
        if u.color == WHITE
            DFS-VISIT(G, u)

DFS-VISIT(G,u)
    time = time + 1
    u.d = time
    for each v in G.Adj[u]
        if v.color == WHITE
            v.parent = u
            DFS-VISIT(G, v)
    u.color = BLACK
    u.f = time
```

深度优先搜索算法的运行时间是 $\Theta (V+E)$


## 深度优先搜索的性质
深度优先搜索提供了很高价值的图结构信息。它生成的前驱子图$G_\pi$ 形成一个由多棵树所构成的森林，这是因为深度优先树的结构与 DFS-VISIT 的递归调用结构完全对应。
深度优先搜索的另一个重要性质是，结点的发现时间和完成时间具有所谓的 **括号化结构**。如  (s (z (x x) z) s).
深度优先搜索的另一个性质是，可以通过搜索来对输入图 $G=(V,E)$ 的边进行分类。**有向图是无环图当且仅当深度优先搜索不产生“后向边”**

对于深度优先森林，可以定义4种边：
1. **树边**：为深度优先森林$G_\pi$中的边。如果结点 $v$ 是因算法对边 $(u,v)$ 的探索而首先被发现的，则$(u,v)$是树边
2. **后向边**： 将结点 $u$ 连接到其在深度优先树中祖先结点 $v$ 的边。由于有向图中可以有自循环，自循环也被认为是后向边。
3. **前向边**：将结点 $u$ 连接到其在尝试优先树中一个后代结点 $v$ 的边 $(u,v)$
4. **横向边**：其他所有边。

当第一次探索 $(u,v)$ 结点时，结点 $v$ 的颜色能够告诉我们关于该条边的信息：
1. 结点 $v$ 是白色表明该条边是树边
2. 结点 $v$ 是灰色表明该边是一条后向边
3. 结点 $v$ 是黒色表明该条边是一条前向边或横向边

# 拓扑排序






----
