---
title: 树算法
date: 2018-01-11 08:37:00
tags: ["算法"]
categories: ["算法"]
---

# 二叉搜索树
搜索树结构支持许多动态结合操作，包括SEARCH、MINMUM、MAXIMUX、PREDECESSOR、SUCCESSOR、INSERT、DELETE等。

二叉搜索树的性质如下：
**设 x 是二叉搜索树的一个结点，如果 y 是 x 左子树中的一个结点，那么 $y.key \leq x.key$，如果y是x右子树的一个结点，那么 $y.key \geq x.key$**

**中序遍历**： 输出的子树根的关键字位于其左子树的关键字和右子树关键字之间
**先序遍历**： 输出的根的关键字在其左右子树关键字之前
**后序遍历**： 输出的根的关键字在其左右子树关键字之后

二叉树的中序遍历算法如下：
```
INORDER-TREE-WALK(x)
    if (x!=NIL)
        INORDER-TREE-WALK(x.left)
        print x.key
        INORDER-TREE-WALK(x.right)
```

## 查询
使用如下递归算法在二叉搜索树中查找一个具有给定关键字的结点：
```
TREE-SEARCH(x,k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return TREE-SEARCH(x.left, key)
    else
        return TREE-SEARCH(x.right, key)
```

查找过程从树根开始，并沿着这棵树中的一条简单路径向下进行。对于每个遇到的结点x，经比较关键字k与x.key。若两个值相等，返回结果。若k小于x.key，继续查找x的左子树；若k大于x.key，继续查找x的右子树。

还可以采用迭代方式代替递归，因为迭代的效率要高得多：
```
ITERATIVE-TREE-SEARCH(x,k)
    while x != NIL and k != x.key
        if k < x.key
            x = x.left
        else 
            x = x.right
    return x
```

## 最大关键字最小关键字
如果结点x没有左子树，那么由于x右子树中的每个关键字都至少大于或等于x.key，则以x为根的子树中的最小关键字是x.key。
如果结点x有左子树，那么由于其右子树中没有关键字小于x.key，且在左子树中的每个关键字不大于x.key，则以x为根的子树中的最小关键字一定在x.left的子树中：
```
TREE-MINMUM(x)
    while x.left != NIL
        x = x.left
    return x

TREE-MAXMUM(x)
    while x.right != NIL
        x = x.right
    return x
```

## 后继和前驱
结点x的后继是大于x.key最小关键字的结点，前驱是小于x.key的最大关键字结点。
```
TREE-SUCCESSOR(x)
    if x.right != NIL
        return TREE-MINMUM(x.right)
    y = x.p
    while y != NIL and x == y.right
        x = y
        y = y.p
    return y
```

如果结点x的右子树非空，那么x的后继是x右子树的最左结点。如果x在右子树为空并有一个后继y，那么y就是x的最底层的祖先，并且y的左孩子也是x的一个祖先。

## 插入
插入和删除操作会引起二叉搜索树集合的变化，一定要修改数据结构来反映这个变化。
算法从树根开始，指针x记录了一条向下的简单路径，并查找要替换的输入项z的NIL，然后将z插入NIL的位置。
```
TREE-INSERT(T,z)
    y = NIL
    x = T.root
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else
            x - x.right
    z.p = y
    if y == NIL
        T.root = z
    elseif z.key < y.key
        y.left = z
    else 
        y.right = z
```

## 删除
从一棵二叉搜索树中删除一个结点 z 的整个策略分为三种基本情况：
1. 如果 z 没有孩子结点，那么只是简单将其删除，并将 z 结点的父结点指向 z 的指针用 NIL 替换
2. 如果 z 只有一个孩子结点，那么将该孩子结点提升到树 z 的位置，并修改 z 的父结点，用 z 的孩子替换 z
3. 如果z 有两个孩子，那么找到 z 的后继 y ，并让 y 占据树中 z 的位置。z 原来的右子树成为 y 的新右子树，z 的左子树成为 y 的新左子树。

第3种情况比较复杂，与 y 是否是 z 的右孩子相关。
- 如果 z 没有左孩子，那么用其右孩子来替换 z
- 如果 z 仅有一个孩子且为左孩子，那么用左孩子替换 z
- 如果 z 既有左孩子又有右孩子。需要查找 z  的后继 y，这个后继位于z 的右子树中并且没有左孩子。现在需要将 y 移出原来的位置进行拼接，并替换树种的 z
- 如果 y 是 z 的右孩子，那么用 y 替换 z，并留下 y 的右孩子。
- y 在 z 的右子树中，但并不是 z 的右孩子。先用 y 的右孩子替换 y，然后再用 y 替换 z。

定义一个移动子树的过程，将一个子树替换为另一个子树：
```
TRANSPLANT(T,u,v)
    if u.p == NIL
        T.root = v
    elseif u == u.p.left
        u.p.left = v
    else
        u.p.right = v
    if v != NIL
        v.p = u.p
```

从搜索二叉树中中删除结点 z 的伪代码如下：
```
TREE-DELETE(T,z)
    if z.left == NIL
        TRANSPLANT(T,z,z.right)
    else z.right == NIL
        TRANSPLANT(T,z,z.left)
    else 
        y = TREE-MINMUM(T, y, y.right)
        if y.p != z
            TRANSPLANT(T, y, y.right)
            y.right = z.right
            y.right.p = y
        TRANSPALAN(T, z, y)
        y.left = z.left
        y.left.p = y
```

在高度为 $h$ 的二叉搜索树上，实现动态集合操作 INSERT 和 DELETE 的运行时间为 $O(h)$.

## 随机构建二叉搜索树
二叉搜索树上的每个基本操作都能在 $O(h)$ 时间内完成。然而，随着元素的插入和删除，二叉搜索树的高度也在变化。如果n个关键字按照严格递增的次序插入，那么这棵树一定是高度为n-1的一条链。但是当n个不同的关键字随机构建二叉搜索树时，期望高度时 $O(\lg n)$。

二叉搜索树的高度较低时，集合操作执行会比较快。但是，如果树的高度较高时，这些集合操作可能并不比在链表上快。因此，引入了平衡搜索树。

# Trie 树

# 红黑树
红黑树是许多平衡所搜树中的一种，可以保证在最坏情况下基本动态集合操作时间复杂度为 $O(\lg n)$

## 红黑树的性质
每个结点上有一个存储位是用来表示结点颜色的，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点颜色的约束，使红黑树没有一条路径会比其他路径长出2倍，因而是近似平衡的。

红黑树满足如下性质：
1. 每个结点不是红色，就是黑色
2. 根结点是黑色的
3. 每个叶结点是黑色的
4. 如果一个结点是红色的，则它的两个子结点是黑色的
5. 对每个结点，从该结点到其后代所有叶节点的简单路径上，均包含相同数目的黑色结点。

**为了便于表示红黑树代码中的边界条件，使用一个哨兵来代表NIL**

**黑高** 从某个结点（不含该结点）出发到达一个叶结点的任意一条简单路径上的黑色结点个数。
